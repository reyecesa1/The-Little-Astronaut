<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Little Astronaut</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #0a0e1a;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
        }
        
        .container {
            position: relative;
            width: 320px;
            height: 320px;
            image-rendering: pixelated;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        .title {
            position: absolute;
            top: 15px;
            left: 15px;
            text-align: left;
            color: #4fc3f7;
            text-shadow: 2px 2px 0 #01579b, 
                         -1px -1px 0 #01579b, 
                         1px -1px 0 #01579b, 
                         -1px 1px 0 #01579b;
            font-size: 14px;
            z-index: 10;
            letter-spacing: 1px;
            max-width: 70%;
            line-height: 1.4;
        }
        
        .signature {
            position: absolute;
            bottom: 15px;
            right: 15px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 10px;
            z-index: 10;
        }
        
        .pixel-art {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <div class="title">THE LITTLE ASTRONAUT</div>
        <canvas id="scene"></canvas>
        <!-- FIXED: Changed signature to match the index.html -->
        <div class="signature">@rmcesar.b</div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('scene');
        const ctx = canvas.getContext('2d');
        const LOGICAL_WIDTH = 320;
        const LOGICAL_HEIGHT = 320;
        
        // Scale for high DPI displays
        const dpi = window.devicePixelRatio || 1;
        canvas.style.width = `${LOGICAL_WIDTH}px`;
        canvas.style.height = `${LOGICAL_HEIGHT}px`;
        canvas.width = LOGICAL_WIDTH * dpi;
        canvas.height = LOGICAL_HEIGHT * dpi;
        ctx.scale(dpi, dpi);
        
        // Animation variables
        let frameCount = 0;
        let lastTime = 0;
        
        // ASTRONAUT SCENE VARIABLES
        let astronautScene = {
            astronaut: {
                x: 150,
                y: 160,
                width: 16,
                height: 24,
                velocityX: (Math.random() - 0.5) * 0.4,
                velocityY: (Math.random() - 0.5) * 0.4,
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 0.01,
                thrust: 0.6,
                maxSpeed: 1.8,
                friction: 0.995,
                jetpackActive: false,
                jetpackDuration: 0,
                isVisible: true,
                jetpackCooldown: 0,
                jetpackIntensity: 0,
                stabilizationMode: false
            },
            stars: [],
            planets: [],
            debris: [],
            particles: [],
            jetpackParticles: [],
            shootingStars: [],
            lastShootingStar: 0,
            initialized: false
        };
        
        // Planet definitions with realistic size ratios
        const planetDefinitions = [
            {
                name: "earth",
                baseSize: 20,
                colors: {
                    base: '#1e88e5',
                    land: '#388e3c',
                    clouds: '#e3f2fd'
                }
            },
            {
                name: "mars",
                baseSize: 11,
                colors: {
                    base: '#e57373',
                    land: '#d32f2f',
                    clouds: '#ffcdd2'
                }
            },
            {
                name: "jupiter",
                baseSize: 45,
                colors: {
                    base: '#ffb74d',
                    stripes: '#ff9800',
                    spot: '#e65100'
                }
            },
            {
                name: "saturn",
                baseSize: 38,
                colors: {
                    base: '#ffcc80',
                    rings: '#a1887f'
                }
            }
        ];
        
        // Debris definitions
        const debrisDefinitions = [
            { type: "satellite", size: 8, color: '#9e9e9e' },
            { type: "metal", size: 5, color: '#bdbdbd' },
            { type: "screw", size: 3, color: '#78909c' },
            { type: "can", size: 6, color: '#f44336' },
            { type: "chip", size: 4, color: '#90a4ae' }
        ];
        
        // Initialize astronaut scene
        function initAstronautScene() {
            if (astronautScene.initialized) return;
            
            // Initialize stars
            for (let i = 0; i < 150; i++) {
                astronautScene.stars.push({
                    x: Math.random() * LOGICAL_WIDTH,
                    y: Math.random() * LOGICAL_HEIGHT,
                    size: Math.random() * 1.5 + 0.5,
                    brightness: Math.random() * 0.6 + 0.4,
                    speed: Math.random() * 0.05 + 0.01
                });
            }
            
            // Initialize planets with different depths and positions
            let nextX = 100;
            let minDistance = 150; // Minimum distance between planets
            
            for (let i = 0; i < 4; i++) {
                const planetDef = planetDefinitions[Math.floor(Math.random() * planetDefinitions.length)];
                
                // Create depth-based scaling (0.3 to 1.5 range)
                const depth = Math.random() * 0.7 + 0.3;
                const size = planetDef.baseSize * depth;
                
                // Calculate y position ensuring planets don't cluster
                let yPos;
                let validPosition = false;
                let attempts = 0;
                
                while (!validPosition && attempts < 20) {
                    yPos = Math.random() * (LOGICAL_HEIGHT - size * 2) + size;
                    validPosition = true;
                    
                    // Check against existing planets
                    for (const existingPlanet of astronautScene.planets) {
                        const dx = nextX - existingPlanet.x;
                        const dy = yPos - existingPlanet.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < minDistance + (size + existingPlanet.size) / 2) {
                            validPosition = false;
                            break;
                        }
                    }
                    
                    attempts++;
                }
                
                astronautScene.planets.push({
                    x: nextX,
                    y: yPos,
                    size: size,
                    type: planetDef.name,
                    colors: planetDef.colors,
                    speed: (Math.random() * 0.1 + 0.05) * (1/depth), // Deeper planets move slower
                    depth: depth,
                    passed: false
                });
                
                // Add more space for the next planet
                nextX += minDistance + Math.random() * 100 + size;
            }
            
            // Initialize space debris
            for (let i = 0; i < 20; i++) {
                const debrisDef = debrisDefinitions[Math.floor(Math.random() * debrisDefinitions.length)];
                astronautScene.debris.push({
                    x: Math.random() * LOGICAL_WIDTH * 3,
                    y: Math.random() * LOGICAL_HEIGHT,
                    size: debrisDef.size,
                    type: debrisDef.type,
                    color: debrisDef.color,
                    speed: Math.random() * 0.3 + 0.1,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.05
                });
            }
            
            astronautScene.initialized = true;
        }
        
        // Draw space background
        function drawSpace() {
            // Deep space background
            ctx.fillStyle = '#000010';
            ctx.fillRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
            
            // Draw stars
            astronautScene.stars.forEach(star => {
                ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
                ctx.fillRect(star.x, star.y, star.size, star.size);
                
                // Move stars slowly
                star.x -= star.speed;
                if (star.x < -5) {
                    star.x = LOGICAL_WIDTH + 5;
                    star.y = Math.random() * LOGICAL_HEIGHT;
                }
            });
            
            // Draw shooting stars
            astronautScene.shootingStars.forEach((star, index) => {
                ctx.strokeStyle = `rgba(255, 255, 255, ${star.opacity})`;
                ctx.lineWidth = star.size;
                
                ctx.beginPath();
                ctx.moveTo(star.x, star.y);
                ctx.lineTo(star.x - star.length, star.y + star.length/2);
                ctx.stroke();
                
                // Update position
                star.x += star.speedX;
                star.y += star.speedY;
                star.opacity -= 0.02;
                
                // Remove when faded out
                if (star.opacity <= 0) {
                    astronautScene.shootingStars.splice(index, 1);
                }
            });
            
            // Random shooting stars (faster and less frequent)
            if (frameCount - astronautScene.lastShootingStar > 750 && Math.random() < 0.005) {
                astronautScene.shootingStars.push({
                    x: Math.random() * LOGICAL_WIDTH,
                    y: -10,
                    speedX: (Math.random() - 0.5) * 4,
                    speedY: Math.random() * 3 + 2,
                    length: Math.random() * 25 + 20,
                    size: Math.random() * 1.5 + 1,
                    opacity: 1
                });
                astronautScene.lastShootingStar = frameCount;
            }
        }
        
        // Draw planets with parallax effect
        function drawPlanets() {
            astronautScene.planets.forEach(planet => {
                // Move planet with depth-based speed
                planet.x -= planet.speed * planet.depth;
                
                // Reset planet if it goes off screen
                if (planet.x < -planet.size * 2) {
                    // Create a new planet with random properties
                    const planetDef = planetDefinitions[Math.floor(Math.random() * planetDefinitions.length)];
                    
                    // Create depth-based scaling
                    const depth = Math.random() * 0.7 + 0.3;
                    const size = planetDef.baseSize * depth;
                    
                    planet.x = LOGICAL_WIDTH + planet.size;
                    planet.y = Math.random() * (LOGICAL_HEIGHT - size * 2) + size;
                    planet.size = size;
                    planet.type = planetDef.name;
                    planet.colors = planetDef.colors;
                    planet.speed = (Math.random() * 0.1 + 0.05) * (1/depth);
                    planet.depth = depth;
                    planet.passed = false;
                }
                
                // Check if planet is passing by the astronaut
                if (!planet.passed && planet.x < LOGICAL_WIDTH/2 + 50 && planet.x > LOGICAL_WIDTH/2 - 50) {
                    planet.passed = true;
                    
                    // Create gravitational particles when planet passes
                    for (let i = 0; i < 15; i++) {
                        astronautScene.particles.push({
                            x: planet.x,
                            y: planet.y,
                            size: Math.random() * 2 + 1,
                            speedX: (Math.random() - 0.5) * 2,
                            speedY: (Math.random() - 0.5) * 2,
                            life: Math.random() * 40 + 20,
                            color: `hsl(${Math.random() * 60 + 180}, 70%, 70%)`
                        });
                    }
                }
                
                // Draw planet based on type
                switch(planet.type) {
                    case "earth":
                        drawEarth(planet);
                        break;
                    case "mars":
                        drawMars(planet);
                        break;
                    case "jupiter":
                        drawJupiter(planet);
                        break;
                    case "saturn":
                        drawSaturn(planet);
                        break;
                }
            });
        }
        
        // Draw Earth
        function drawEarth(planet) {
            const {x, y, size, colors} = planet;
            
            // Earth base
            ctx.fillStyle = colors.base;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            
            // Continents
            ctx.fillStyle = colors.land;
            ctx.beginPath();
            ctx.arc(x - size/3, y - size/4, size/3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(x + size/4, y + size/5, size/4, 0, Math.PI * 2);
            ctx.fill();
            
            // Clouds
            ctx.fillStyle = colors.clouds;
            ctx.beginPath();
            ctx.arc(x - size/5, y - size/6, size/6, 0, Math.PI * 2);
            ctx.arc(x - size/8, y - size/8, size/8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(x + size/3, y - size/5, size/7, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw Mars
        function drawMars(planet) {
            const {x, y, size, colors} = planet;
            
            // Mars base
            ctx.fillStyle = colors.base;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            
            // Features
            ctx.fillStyle = colors.land;
            ctx.beginPath();
            ctx.arc(x - size/4, y + size/5, size/4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(x + size/3, y - size/4, size/5, 0, Math.PI * 2);
            ctx.fill();
            
            // Ice caps
            ctx.fillStyle = colors.clouds;
            ctx.beginPath();
            ctx.arc(x, y - size * 0.7, size/5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(x, y + size * 0.7, size/6, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw Jupiter
        function drawJupiter(planet) {
            const {x, y, size, colors} = planet;
            
            // Jupiter base
            ctx.fillStyle = colors.base;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            
            // Stripes
            ctx.fillStyle = colors.stripes;
            for (let i = -4; i <= 4; i++) {
                const stripeY = y + (i * size/5);
                const stripeWidth = size * 0.9;
                const stripeHeight = size/10;
                
                ctx.beginPath();
                ctx.ellipse(x, stripeY, stripeWidth/2, stripeHeight, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Great Red Spot
            ctx.fillStyle = colors.spot;
            ctx.beginPath();
            ctx.arc(x - size/3, y - size/4, size/6, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw Saturn
        function drawSaturn(planet) {
            const {x, y, size, colors} = planet;
            
            // Saturn base
            ctx.fillStyle = colors.base;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            
            // Rings
            ctx.fillStyle = colors.rings;
            ctx.beginPath();
            ctx.ellipse(x, y, size * 1.4, size/6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Ring shadow on planet
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(x, y, size * 1.4, size/6, 0, 0, Math.PI);
            ctx.fill();
        }
        
        // Draw space debris
        function drawDebris() {
            astronautScene.debris.forEach(debris => {
                // Move debris
                debris.x -= debris.speed;
                debris.rotation += debris.rotationSpeed;
                
                // Reset debris if it goes off screen
                if (debris.x < -20) {
                    debris.x = LOGICAL_WIDTH + 20;
                    debris.y = Math.random() * LOGICAL_HEIGHT;
                }
                
                ctx.save();
                ctx.translate(debris.x, debris.y);
                ctx.rotate(debris.rotation);
                
                // Draw based on debris type
                switch(debris.type) {
                    case "satellite":
                        // Draw satellite debris
                        ctx.fillStyle = debris.color;
                        ctx.fillRect(-debris.size/2, -debris.size/2, debris.size, debris.size);
                        
                        ctx.fillStyle = '#90caf9';
                        ctx.fillRect(-debris.size/2 + 2, -debris.size/2 + 2, debris.size - 4, 2);
                        break;
                    case "metal":
                        // Draw metal debris
                        ctx.fillStyle = debris.color;
                        ctx.beginPath();
                        ctx.moveTo(-debris.size/2, -debris.size/2);
                        ctx.lineTo(debris.size/2, -debris.size/2);
                        ctx.lineTo(debris.size/2, debris.size/2);
                        ctx.lineTo(-debris.size/2, debris.size/2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case "screw":
                        // Draw screw debris
                        ctx.fillStyle = debris.color;
                        ctx.beginPath();
                        ctx.arc(0, 0, debris.size/2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#455a64';
                        ctx.fillRect(-1, -debris.size, 2, debris.size);
                        break;
                    case "can":
                        // Draw can debris
                        ctx.fillStyle = debris.color;
                        ctx.fillRect(-debris.size/2, -debris.size/3, debris.size, debris.size/1.5);
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(-debris.size/2 + 2, -debris.size/3 + 2, debris.size - 4, 4);
                        break;
                    case "chip":
                        // Draw chip debris
                        ctx.fillStyle = debris.color;
                        ctx.fillRect(-debris.size/2, -debris.size/2, debris.size, debris.size);
                        
                        ctx.fillStyle = '#263238';
                        for (let i = 0; i < 4; i++) {
                            ctx.fillRect(-debris.size/2 + 2 + i*3, -debris.size/2 + 2, 1, debris.size - 4);
                        }
                        break;
                }
                
                ctx.restore();
            });
        }
        
        // Activate jetpack randomly
        function activateRandomJetpack() {
            const astronaut = astronautScene.astronaut;
            
            if (astronaut.jetpackCooldown <= 0 && Math.random() < 0.006 && astronaut.isVisible) {
                astronaut.jetpackActive = true;
                astronaut.jetpackDuration = Math.random() * 25 + 15;
                astronaut.jetpackCooldown = Math.random() * 150 + 100;
                astronaut.jetpackIntensity = Math.random() * 0.6 + 0.5;
                
                // Apply impulse in a random direction
                const angle = Math.random() * Math.PI * 2;
                const strength = Math.random() * astronaut.thrust * astronaut.jetpackIntensity + 0.3;
                
                astronaut.velocityX += Math.cos(angle) * strength;
                astronaut.velocityY += Math.sin(angle) * strength;
                
                // Apply random rotation
                astronaut.rotationSpeed += (Math.random() - 0.5) * 0.08;
            }
        }
        
        // Activate stabilization jets when out of bounds
        function activateStabilizationJets() {
            const astronaut = astronautScene.astronaut;
            const boundsMargin = 60;
            
            // Check if out of bounds
            const isOutOfBounds = 
                astronaut.x < -boundsMargin || 
                astronaut.x > LOGICAL_WIDTH + boundsMargin ||
                astronaut.y < -boundsMargin || 
                astronaut.y > LOGICAL_HEIGHT + boundsMargin;
            
            if (isOutOfBounds && !astronaut.stabilizationMode) {
                astronaut.stabilizationMode = true;
                astronaut.jetpackActive = true;
                astronaut.jetpackDuration = 40;
            }
            
            // If in stabilization mode, apply force toward center
            if (astronaut.stabilizationMode) {
                const centerX = LOGICAL_WIDTH / 2;
                const centerY = LOGICAL_HEIGHT / 2;
                
                // Calculate direction to center
                const dirX = centerX - astronaut.x;
                const dirY = centerY - astronaut.y;
                
                // Normalize and apply force
                const distance = Math.sqrt(dirX * dirX + dirY * dirY);
                if (distance > 0) {
                    astronaut.velocityX += (dirX / distance) * 0.08;
                    astronaut.velocityY += (dirY / distance) * 0.08;
                }
                
                // Reduce rotation speed for stabilization
                astronaut.rotationSpeed *= 0.95;
                
                // Check if back in reasonable bounds
                const reasonableBounds = 100;
                if (
                    astronaut.x > -reasonableBounds && 
                    astronaut.x < LOGICAL_WIDTH + reasonableBounds &&
                    astronaut.y > -reasonableBounds && 
                    astronaut.y < LOGICAL_HEIGHT + reasonableBounds
                ) {
                    astronaut.stabilizationMode = false;
                }
            }
        }
        
        // Draw astronaut
        function drawAstronaut() {
            const astronaut = astronautScene.astronaut;
            
            // Update astronaut position with natural drift
            astronaut.x += astronaut.velocityX;
            astronaut.y += astronaut.velocityY;
            
            // Apply slight friction
            astronaut.velocityX *= astronaut.friction;
            astronaut.velocityY *= astronaut.friction;
            
            // Update rotation
            astronaut.rotation += astronaut.rotationSpeed;
            astronaut.rotationSpeed *= 0.99; // Slow down rotation over time
            
            // Handle jetpack cooldown
            if (astronaut.jetpackCooldown > 0) {
                astronaut.jetpackCooldown--;
            }
            
            // Random jetpack activation
            activateRandomJetpack();
            
            // Stabilization jets when out of bounds
            activateStabilizationJets();
            
            // Handle jetpack
            if (astronaut.jetpackActive) {
                astronaut.jetpackDuration--;
                
                if (astronaut.jetpackDuration <= 0) {
                    astronaut.jetpackActive = false;
                } else {
                    drawJetpackFlames();
                }
            }
            
            // Only draw if visible
            if (astronaut.isVisible) {
                ctx.save();
                ctx.translate(astronaut.x + astronaut.width/2, astronaut.y + astronaut.height/2);
                ctx.rotate(astronaut.rotation);
                
                // Draw astronaut (pixel art style)
                ctx.fillStyle = '#374151';
                ctx.fillRect(-astronaut.width/2, -astronaut.height/2, astronaut.width, astronaut.height);
                
                // Helmet visor
                ctx.fillStyle = '#4fc3f7';
                ctx.fillRect(-astronaut.width/2 + 3, -astronaut.height/2 + 5, 10, 8);
                
                // Helmet reflection
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fillRect(-astronaut.width/2 + 10, -astronaut.height/2 + 6, 2, 2);
                
                // Jetpack
                ctx.fillStyle = '#9ca3af';
                ctx.fillRect(-astronaut.width/2 - 4, -astronaut.height/2 + 5, 4, 12);
                
                // Jetpack details
                ctx.fillStyle = '#3b82f6';
                ctx.fillRect(-astronaut.width/2 - 3, -astronaut.height/2 + 7, 2, 3);
                ctx.fillRect(-astronaut.width/2 - 3, -astronaut.height/2 + 13, 2, 3);
                
                // Arms and legs
                ctx.fillStyle = '#374151';
                
                // Arms
                ctx.fillRect(-astronaut.width/2 - 4, -astronaut.height/2 + 8, 4, 2);
                ctx.fillRect(astronaut.width/2, -astronaut.height/2 + 8, 4, 2);
                
                // Legs
                ctx.fillRect(-astronaut.width/2 + 2, astronaut.height/2, 4, 6);
                ctx.fillRect(-astronaut.width/2 + 10, astronaut.height/2, 4, 6);
                
                // Boots
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(-astronaut.width/2 + 1, astronaut.height/2 + 6, 6, 2);
                ctx.fillRect(-astronaut.width/2 + 9, astronaut.height/2 + 6, 6, 2);
                
                ctx.restore();
            }
        }
        
        // Draw jetpack flames
        function drawJetpackFlames() {
            const astronaut = astronautScene.astronaut;
            
            // Calculate nozzle positions relative to astronaut center
            const cos = Math.cos(astronaut.rotation);
            const sin = Math.sin(astronaut.rotation);
            
            // Nozzle positions (relative to astronaut center)
            const nozzle1LocalX = -astronaut.width/2 - 2;
            const nozzle1LocalY = -astronaut.height/2 + 8.5;
            const nozzle2LocalX = -astronaut.width/2 - 2;
            const nozzle2LocalY = -astronaut.height/2 + 14.5;
            
            // Transform to world coordinates
            const nozzle1X = astronaut.x + astronaut.width/2 + (nozzle1LocalX * cos - nozzle1LocalY * sin);
            const nozzle1Y = astronaut.y + astronaut.height/2 + (nozzle1LocalX * sin + nozzle1LocalY * cos);
            
            const nozzle2X = astronaut.x + astronaut.width/2 + (nozzle2LocalX * cos - nozzle2LocalY * sin);
            const nozzle2Y = astronaut.y + astronaut.height/2 + (nozzle2LocalX * sin + nozzle2LocalY * cos);
            
            // Create new jetpack particles from both nozzles
            for (let i = 0; i < 3; i++) {
                // Alternate between nozzles
                const nozzleX = i % 2 === 0 ? nozzle1X : nozzle2X;
                const nozzleY = i % 2 === 0 ? nozzle1Y : nozzle2Y;
                
                // Direction opposite to astronaut's facing direction
                const directionX = -cos;
                const directionY = -sin;
                
                // For stabilization mode, adjust direction toward center
                let finalDirectionX = directionX;
                let finalDirectionY = directionY;
                let intensity = astronaut.jetpackIntensity;
                
                if (astronaut.stabilizationMode) {
                    const centerX = LOGICAL_WIDTH / 2;
                    const centerY = LOGICAL_HEIGHT / 2;
                    const dirX = centerX - astronaut.x;
                    const dirY = centerY - astronaut.y;
                    const distance = Math.sqrt(dirX * dirX + dirY * dirY);
                    
                    if (distance > 0) {
                        finalDirectionX = dirX / distance;
                        finalDirectionY = dirY / distance;
                        intensity = 0.8; // Stronger for stabilization
                    }
                }
                
                astronautScene.jetpackParticles.push({
                    x: nozzleX,
                    y: nozzleY,
                    size: Math.random() * 1.5 + 1,
                    speedX: finalDirectionX * (Math.random() * 1.2 + 1.0) * intensity + (Math.random() - 0.5) * 0.5,
                    speedY: finalDirectionY * (Math.random() * 1.2 + 1.0) * intensity + (Math.random() - 0.5) * 0.5,
                    life: Math.random() * 25 + 15,
                    color: `hsl(${Math.random() * 20 + 20}, 100%, ${Math.random() * 30 + 60}%)`
                });
            }
            
            // Draw and update jetpack particles
            astronautScene.jetpackParticles.forEach((particle, index) => {
                particle.x += particle.speedX;
                particle.y += particle.speedY;
                particle.life--;
                
                // Fade out as life decreases
                const alpha = Math.min(1, particle.life / 20);
                ctx.fillStyle = particle.color.replace('%)', `%, ${alpha})`);
                ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
                
                // Remove dead particles
                if (particle.life <= 0) {
                    astronautScene.jetpackParticles.splice(index, 1);
                }
            });
        }
        
        // Draw particles
        function drawParticles() {
            astronautScene.particles.forEach((particle, index) => {
                particle.x += particle.speedX;
                particle.y += particle.speedY;
                particle.life--;
                
                ctx.fillStyle = particle.color;
                ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
                
                // Remove dead particles
                if (particle.life <= 0) {
                    astronautScene.particles.splice(index, 1);
                }
            });
            
            // Create random space dust particles
            if (Math.random() < 0.1) {
                astronautScene.particles.push({
                    x: Math.random() * LOGICAL_WIDTH,
                    y: Math.random() * LOGICAL_HEIGHT,
                    size: Math.random() * 1 + 0.5,
                    speedX: Math.random() * 0.5 - 0.25,
                    speedY: Math.random() * 0.5 - 0.25,
                    life: Math.random() * 30 + 10,
                    color: 'rgba(255, 255, 255, 0.7)'
                });
            }
        }
        
        // Main animation loop
        function animate(currentTime) {
            if (!lastTime) lastTime = currentTime;
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Clear canvas
            ctx.clearRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
            
            // Draw the scene
            drawSpace();
            drawPlanets();
            drawDebris();
            drawParticles();
            drawAstronaut();
            
            // Increment frame counter
            frameCount++;
            
            // Request next frame
            requestAnimationFrame(animate);
        }
        
        // Initialize and start the animation
        function init() {
            initAstronautScene();
            requestAnimationFrame(animate);
        }
        
        // Start everything
        init();
        
        // Ensure animation continues when tab is not visible
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                lastTime = 0;
                requestAnimationFrame(animate);
            }
        });
    </script>
</body>
</html>

